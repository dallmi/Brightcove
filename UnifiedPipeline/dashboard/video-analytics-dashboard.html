<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brightcove Video Analytics Dashboard</title>

    <!-- Preconnect to CDN for faster resource loading -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

    <!-- Chart.js (defer to avoid blocking first paint) -->
    <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- SheetJS for XLSX export (defer to avoid blocking first paint) -->
    <script defer src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <!-- Chart.js Geo plugin (includes topojson-client) -->
    <script defer src="https://cdn.jsdelivr.net/npm/chartjs-chart-geo@4.3.2/build/index.umd.min.js"></script>

    <!-- DuckDB WASM -->
    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm';
        window.duckdb = duckdb;
        window.dispatchEvent(new Event('duckdb-ready'));
    </script>

    <style>
        :root {
            --primary: #BD000C;
            --primary-dark: #9A000A;
            --primary-light: #D4353F;
            --black: #000000;
            --dark-gray: #333333;
            --medium-gray: #666666;
            --light-gray: #D9D9D9;
            --lighter-gray: #F5F5F5;
            --white: #FFFFFF;
            --success: #6F7A1A;
            --success-light: #F0F2E6;
            --warning: #E4A911;
            --warning-light: #FDF6E3;
            --danger: #BD000C;
            --danger-light: #FCEAEB;
            --info: #333333;
            --info-light: #ECECEC;
            --row-alt: #FAFAFA;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--lighter-gray);
            color: var(--dark-gray);
            line-height: 1.5;
        }

        .header {
            background: var(--white);
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--light-gray);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            padding-left: 0.75rem;
            border-left: 3px solid var(--primary);
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .date-filter {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .date-presets {
            display: flex;
            gap: 0;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            overflow: hidden;
            margin-right: 0.5rem;
        }

        .date-preset {
            padding: 0.35rem 0.6rem;
            background: var(--white);
            border: none;
            border-right: 1px solid var(--light-gray);
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--medium-gray);
            white-space: nowrap;
            transition: all 0.15s;
        }

        .date-preset:last-child { border-right: none; }
        .date-preset:hover { background: var(--lighter-gray); color: var(--dark-gray); }
        .date-preset.active { background: var(--primary); color: var(--white); }

        .date-filter label {
            font-size: 0.8rem;
            color: var(--medium-gray);
        }

        .date-filter input {
            padding: 0.4rem 0.5rem;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .btn {
            padding: 0.4rem 0.75rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--white);
        }

        .btn-primary:hover { background: var(--primary-dark); }

        .btn-secondary {
            background: transparent;
            color: var(--dark-gray);
            border: 1px solid var(--light-gray);
        }

        .btn-secondary:hover { background: var(--light-gray); }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 0;
            background: var(--white);
            border-radius: 8px 8px 0 0;
            border-bottom: 2px solid var(--light-gray);
            overflow-x: auto;
        }

        .nav-tabs.loading, .filter-bar.loading, .date-filter.loading {
            opacity: 0.4;
            pointer-events: none;
        }

        .nav-tab {
            padding: 0.75rem 1.25rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--medium-gray);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .nav-tab:hover {
            color: var(--dark-gray);
            background: var(--lighter-gray);
        }

        .nav-tab.active {
            color: var(--black);
            border-bottom-color: var(--primary);
        }

        .nav-content {
            display: none;
            background: var(--white);
            border-radius: 0 0 8px 8px;
            padding: 1rem;
        }

        .nav-content.active { display: block; }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 40vh;
            gap: 1rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--light-gray);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text {
            color: var(--medium-gray);
            font-size: 0.85rem;
        }

        /* KPI Cards */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .kpi-card {
            background: var(--white);
            border-radius: 6px;
            padding: 1rem;
            border: 1px solid var(--light-gray);
            position: relative;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
            border-radius: 6px 6px 0 0;
        }

        .kpi-card.highlight::before { background: var(--primary); }
        .kpi-card.success::before { background: var(--success); }
        .kpi-card.warning::before { background: var(--warning); }
        .kpi-card.info::before { background: var(--info); }

        .kpi-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: var(--medium-gray);
            margin-bottom: 0.25rem;
        }

        .kpi-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--black);
            line-height: 1.2;
        }

        .kpi-subtitle {
            font-size: 0.65rem;
            color: var(--medium-gray);
            margin-top: 0.25rem;
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .chart-card {
            background: var(--white);
            border-radius: 6px;
            padding: 1rem;
            border: 1px solid var(--light-gray);
        }

        .chart-card.full-width { grid-column: 1 / -1; }

        .chart-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chart-subtitle {
            font-size: 0.7rem;
            color: var(--medium-gray);
            font-weight: 400;
        }

        .chart-container { height: 250px; position: relative; }
        .chart-container.tall { height: 350px; }
        .chart-container.short { height: 180px; }

        /* Map */
        .map-container {
            position: relative;
            height: 480px;
            width: 100%;
        }
        .map-container canvas {
            width: 100% !important;
            height: 100% !important;
            cursor: pointer;
        }
        .map-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .map-breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.85rem;
        }
        .map-crumb {
            color: var(--primary);
            cursor: pointer;
            font-weight: 500;
        }
        .map-crumb:hover { text-decoration: underline; }
        .map-crumb.active {
            color: var(--dark-gray);
            cursor: default;
            font-weight: 600;
        }
        .map-crumb.active:hover { text-decoration: none; }
        .map-separator {
            color: var(--medium-gray);
            font-size: 0.75rem;
        }
        .map-zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            z-index: 10;
        }
        .map-zoom-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--light-gray);
            background: var(--white);
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--dark-gray);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-zoom-btn:hover {
            background: var(--lighter-gray);
            border-color: var(--medium-gray);
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        th {
            background: var(--lighter-gray);
            padding: 0.6rem 0.75rem;
            text-align: left;
            font-weight: 600;
            color: var(--dark-gray);
            border-bottom: 1px solid var(--light-gray);
            position: sticky;
            top: 0;
            z-index: 1;
            cursor: pointer;
        }

        th:hover { background: var(--light-gray); }

        td {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--light-gray);
            color: var(--dark-gray);
        }

        tbody tr:nth-child(even) td { background: var(--row-alt); }
        tr:hover td { background: var(--lighter-gray); }

        .text-right { text-align: right; }

        .badge {
            display: inline-block;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-success { background: var(--success-light); color: var(--success); }
        .badge-warning { background: var(--warning-light); color: var(--warning); }
        .badge-danger { background: var(--danger-light); color: var(--danger); }
        .badge-info { background: var(--info-light); color: var(--info); }

        /* Search */
        .search-input {
            flex: 1;
            max-width: 400px;
            padding: 0.4rem 0.75rem;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .table-controls {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            align-items: center;
        }

        /* Executive Summary */
        .executive-summary {
            background: linear-gradient(135deg, var(--white) 0%, var(--lighter-gray) 100%);
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1rem;
            border: 1px solid var(--light-gray);
        }

        .summary-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: 0.75rem;
        }

        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 0.75rem;
        }

        .insight-card {
            background: var(--white);
            border-radius: 6px;
            padding: 0.75rem;
            border-left: 3px solid var(--info);
        }

        .insight-card.positive { border-left-color: var(--success); }
        .insight-card.negative { border-left-color: var(--danger); }
        .insight-card.warning { border-left-color: var(--warning); }

        .insight-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: 0.25rem;
        }

        .insight-text {
            font-size: 0.75rem;
            color: var(--medium-gray);
            line-height: 1.4;
        }

        /* Status bar */
        .status-bar {
            font-size: 0.7rem;
            color: var(--medium-gray);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }

        .status-dot.loading { background: var(--warning); }
        .status-dot.error { background: var(--danger); }

        .section-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin: 1rem 0 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--light-gray);
        }

        /* Filter bar */
        .filter-bar {
            background: var(--white);
            padding: 0.6rem 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            border-bottom: 1px solid var(--light-gray);
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            gap: 0.4rem;
            align-items: center;
        }

        .filter-group label {
            font-size: 0.75rem;
            color: var(--medium-gray);
            font-weight: 500;
        }

        .filter-group select {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            font-size: 0.8rem;
            min-width: 160px;
        }

        .filter-group select:focus,
        .filter-group .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Multi-select dropdown */
        .multi-select {
            position: relative;
            min-width: 180px;
        }

        .multi-select-toggle {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            font-size: 0.8rem;
            background: var(--white);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
            user-select: none;
        }

        .multi-select-toggle:hover { border-color: var(--medium-gray); }
        .multi-select-toggle.open { border-color: var(--primary); }

        .multi-select-toggle .arrow {
            font-size: 0.6rem;
            color: var(--medium-gray);
        }

        .multi-select-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--white);
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            margin-top: 2px;
            max-height: 240px;
            overflow-y: auto;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .multi-select-dropdown.open { display: block; }

        .multi-select-option {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.6rem;
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--dark-gray);
        }

        .multi-select-option:hover { background: var(--lighter-gray); }

        .multi-select-option input[type="checkbox"] {
            accent-color: var(--primary);
        }

        .channel-search {
            width: 100%;
            padding: 0.4rem 0.6rem;
            border: none;
            border-bottom: 1px solid var(--light-gray);
            font-size: 0.8rem;
            outline: none;
            position: sticky;
            top: 0;
            background: var(--white);
            z-index: 1;
        }

        .channel-search:focus { border-bottom-color: var(--primary); }

        /* Autocomplete */
        .autocomplete-wrapper {
            position: relative;
        }

        .autocomplete-list {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            min-width: 350px;
            background: var(--white);
            border: 1px solid var(--light-gray);
            border-radius: 4px;
            margin-top: 2px;
            max-height: 260px;
            overflow-y: auto;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .autocomplete-list.open { display: block; }

        .autocomplete-item {
            padding: 0.45rem 0.6rem;
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--dark-gray);
            border-bottom: 1px solid var(--lighter-gray);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .autocomplete-item:last-child { border-bottom: none; }
        .autocomplete-item:hover,
        .autocomplete-item.active { background: var(--lighter-gray); }

        .autocomplete-item .channel-hint {
            font-size: 0.7rem;
            color: var(--medium-gray);
            margin-left: 0.4rem;
        }

        .autocomplete-item mark {
            background: transparent;
            color: var(--primary);
            font-weight: 600;
        }

        .active-filters {
            display: flex;
            gap: 0.4rem;
            align-items: center;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .filter-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0.5rem;
            background: var(--info-light);
            color: var(--info);
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 500;
        }

        .filter-tag .remove {
            cursor: pointer;
            font-weight: 700;
            font-size: 0.8rem;
            line-height: 1;
        }

        .filter-tag .remove:hover { color: var(--danger); }

        /* Responsive */
        @media (max-width: 768px) {
            .header { flex-direction: column; gap: 0.5rem; padding: 0.5rem 1rem; }
            .charts-grid { grid-template-columns: 1fr; }
            .kpi-grid { grid-template-columns: repeat(2, 1fr); }
            .nav-tabs { overflow-x: auto; }
            .date-filter { flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Brightcove Video Analytics Dashboard</h1>
        <div class="header-controls">
            <div class="date-filter loading" id="dateFilterControls">
                <div class="date-presets">
                    <button class="date-preset" data-preset="7d" onclick="applyDatePreset('7d')">Last 7 days</button>
                    <button class="date-preset" data-preset="30d" onclick="applyDatePreset('30d')">Last 30 days</button>
                    <button class="date-preset" data-preset="this-month" onclick="applyDatePreset('this-month')">This month</button>
                    <button class="date-preset" data-preset="last-month" onclick="applyDatePreset('last-month')">Last month</button>
                    <button class="date-preset" data-preset="ytd" onclick="applyDatePreset('ytd')">This year</button>
                    <button class="date-preset" data-preset="last-year" onclick="applyDatePreset('last-year')">Last year</button>
                    <button class="date-preset" data-preset="all" onclick="applyDatePreset('all')">All time</button>
                </div>
                <label>From:</label>
                <input type="date" id="dateFrom">
                <label>To:</label>
                <input type="date" id="dateTo">
                <button class="btn btn-primary" onclick="applyDateFilter()">Apply</button>
                <button class="btn btn-secondary" onclick="resetDateFilter()">Reset</button>
            </div>
            <div class="status-bar">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Initializing...</span>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="nav-tabs loading" id="navTabs">
            <button class="nav-tab active" data-nav="overview">Overview</button>
            <button class="nav-tab" data-nav="content">Content</button>
            <button class="nav-tab" data-nav="channels">Channels</button>
            <button class="nav-tab" data-nav="devices">Devices</button>
            <button class="nav-tab" data-nav="regional">Regional</button>
            <button class="nav-tab" data-nav="lifecycle">Lifecycle</button>
            <button class="nav-tab" data-nav="videotable">Video Table</button>
        </div>

        <!-- Global Filters -->
        <div class="filter-bar loading" id="filterBar">
            <div class="filter-group">
                <label>Channel:</label>
                <div class="multi-select" id="channelMultiSelect">
                    <div class="multi-select-toggle" onclick="toggleChannelDropdown()">
                        <span id="channelToggleLabel">All Channels</span>
                        <span class="arrow">&#9662;</span>
                    </div>
                    <div class="multi-select-dropdown" id="channelDropdown">
                        <input type="text" class="channel-search" id="channelSearchInput" placeholder="Filter channels..." oninput="filterChannelOptions()">
                        <div id="channelOptions"></div>
                    </div>
                </div>
            </div>
            <div class="filter-group">
                <label>Video:</label>
                <div class="autocomplete-wrapper">
                    <input type="text" class="search-input" id="videoSearch" placeholder="Search by name..." oninput="onVideoSearchInput()" onkeydown="onVideoSearchKeydown(event)" autocomplete="off">
                    <div class="autocomplete-list" id="videoAutocomplete"></div>
                </div>
            </div>
            <div id="activeFilters" class="active-filters"></div>
        </div>

        <!-- Loading State -->
        <div id="loadingState" class="loading">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Initializing DuckDB...</div>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboardContent" style="display: none;">

            <!-- Overview Tab -->
            <div class="nav-content active" id="nav-overview">
                <div id="executiveSummary"></div>
                <div id="kpiCards" class="kpi-grid"></div>
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-title">Monthly Views</div>
                        <div class="chart-container"><canvas id="chartMonthlyViews"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Monthly Engagement</div>
                        <div class="chart-container"><canvas id="chartMonthlyEngagement"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Engagement Funnel</div>
                        <div class="chart-container tall"><canvas id="chartFunnel"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Views by Channel</div>
                        <div class="chart-container tall"><canvas id="chartChannelViews"></canvas></div>
                    </div>
                </div>
            </div>

            <!-- Content Tab -->
            <div class="nav-content" id="nav-content">
                <h3 class="section-title">Content Trends</h3>
                <p style="font-size:0.75rem; color:var(--medium-gray); margin-bottom:0.5rem;">Hours viewed per week for the top 10 videos by total watch time.</p>
                <div class="charts-grid">
                    <div class="chart-card full-width">
                        <div class="chart-title">Popular Content by Title
                            <span class="chart-subtitle">weekly hours viewed</span>
                        </div>
                        <div class="chart-container tall"><canvas id="chartContentTrends"></canvas></div>
                    </div>
                </div>
                <h3 class="section-title">Top Videos by Watch Hours</h3>
                <div id="topVideosByWatchHours"></div>
                <h3 class="section-title">Duration Sweet Spot</h3>
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-title">Completion Rate by Duration</div>
                        <div class="chart-container"><canvas id="chartDurationCompletion"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Total Views by Duration</div>
                        <div class="chart-container"><canvas id="chartDurationViews"></canvas></div>
                    </div>
                </div>
                <h3 class="section-title">Top Videos by Views</h3>
                <div id="topVideosByViews"></div>
                <h3 class="section-title">Top Videos by Engagement (min. 100 views)</h3>
                <div id="topVideosByEngagement"></div>
                <h3 class="section-title">Low Play Rate Videos</h3>
                <p style="font-size:0.75rem; color:var(--medium-gray); margin-bottom:0.5rem;">High impressions but low play rate -- may need better thumbnails or titles.</p>
                <div id="lowPlayRate"></div>
            </div>

            <!-- Channels Tab -->
            <div class="nav-content" id="nav-channels">
                <h3 class="section-title">Channel Performance</h3>
                <div id="channelTable"></div>
                <div class="charts-grid" style="margin-top:1rem;">
                    <div class="chart-card">
                        <div class="chart-title">Views per Video by Channel</div>
                        <div class="chart-container tall"><canvas id="chartChannelEfficiency"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Engagement by Channel</div>
                        <div class="chart-container tall"><canvas id="chartChannelEngagement"></canvas></div>
                    </div>
                </div>
                <h3 class="section-title">Engagement Funnel by Channel</h3>
                <div id="channelFunnelTable"></div>
            </div>

            <!-- Devices Tab -->
            <div class="nav-content" id="nav-devices">
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-title">Views by Device Type</div>
                        <div class="chart-container tall"><canvas id="chartDevicePie"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Device Breakdown</div>
                        <div class="chart-container tall"><canvas id="chartDeviceBar"></canvas></div>
                    </div>
                    <div class="chart-card full-width">
                        <div class="chart-title">Mobile vs Desktop Trend</div>
                        <div class="chart-container"><canvas id="chartDeviceTrend"></canvas></div>
                    </div>
                </div>
            </div>

            <!-- Regional Tab -->
            <div class="nav-content" id="nav-regional">
                <!-- Interactive Map -->
                <div id="mapSection">
                    <div class="map-header">
                        <div class="map-breadcrumb" id="mapBreadcrumb">
                            <span class="map-crumb active">World</span>
                        </div>
                    </div>
                    <div class="chart-card full-width">
                        <div class="chart-title" id="mapTitle">Minutes Viewed by Location</div>
                        <div class="map-container" id="mapContainer">
                            <canvas id="chartGeoMap"></canvas>
                            <div class="map-zoom-controls">
                                <button class="map-zoom-btn" onclick="mapZoomIn()" title="Zoom in">+</button>
                                <button class="map-zoom-btn" onclick="mapZoomOut()" title="Zoom out">−</button>
                            </div>
                        </div>
                    </div>
                    <div id="mapDrillDetail" style="display:none;"></div>
                </div>

                <h3 class="section-title">Views by Country</h3>
                <div class="charts-grid">
                    <div class="chart-card">
                        <div class="chart-title">Top Countries by Views</div>
                        <div class="chart-container tall"><canvas id="chartCountryViews"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-title">Completion Rate by Country
                            <span class="chart-subtitle">min. 100 views</span>
                        </div>
                        <div class="chart-container tall"><canvas id="chartCountryEngagement"></canvas></div>
                    </div>
                </div>
                <h3 class="section-title">Avg Watch Time vs Viewers by Country</h3>
                <p style="font-size:0.75rem; color:var(--medium-gray); margin-bottom:0.5rem;">Bubble size = total watch hours. X = total views, Y = avg seconds viewed per view.</p>
                <div class="charts-grid">
                    <div class="chart-card full-width">
                        <div class="chart-container tall"><canvas id="chartCountryBubble"></canvas></div>
                    </div>
                </div>
                <h3 class="section-title">Country Detail</h3>
                <div id="countryTable"></div>
                <h3 class="section-title">Top Videos by Country</h3>
                <p style="font-size:0.75rem; color:var(--medium-gray); margin-bottom:0.5rem;">Select a country above or use the table to see top-performing videos per region.</p>
                <div id="countryTopVideos"></div>
            </div>

            <!-- Lifecycle Tab -->
            <div class="nav-content" id="nav-lifecycle">
                <h3 class="section-title">Stale Content (Not viewed in 180+ days)</h3>
                <p style="font-size:0.75rem; color:var(--medium-gray); margin-bottom:0.5rem;">Videos that once had audience interest but haven't been viewed recently. Candidates for archival or refresh.</p>
                <div id="staleContent"></div>
                <h3 class="section-title">Top Performers (Last 30 Days)</h3>
                <div id="recentPerformers"></div>
            </div>

            <!-- Video Table Tab -->
            <div class="nav-content" id="nav-videotable">
                <div class="table-controls" style="flex-wrap:wrap;">
                    <button class="btn btn-secondary" onclick="exportVideoTable('csv')">Export CSV</button>
                    <button class="btn btn-secondary" onclick="exportVideoTable('excel')">Export Excel</button>
                    <span style="font-size:0.75rem;color:var(--medium-gray);margin-left:auto;" id="videoTableCount"></span>
                </div>
                <div id="videoTableContainer"></div>
                <div id="videoTablePagination" style="display:flex;gap:0.5rem;align-items:center;justify-content:center;margin-top:0.75rem;"></div>
            </div>

        </div>
    </div>

    <script>
        // ====================================================================
        // GLOBALS
        // ====================================================================
        let db, conn;
        let dateFilter = { from: null, to: null };
        let channelFilterValue = [];
        let videoSearchValue = '';
        let debounceTimer = null;
        let charts = {};
        let allChannels = [];

        const COLORS = {
            primary: '#BD000C',
            primaryLight: '#D4353F',
            success: '#6F7A1A',
            warning: '#E4A911',
            danger: '#BD000C',
            info: '#333333',
            // Default chart color: dark gray (use for single-series neutral charts)
            chart: '#555555',
            chartLight: '#77777799',
            // Gray palette for multi-series charts (no semantic meaning)
            palette: [
                '#333333', '#666666', '#888888', '#AAAAAA', '#555555',
                '#777777', '#999999', '#BBBBBB', '#444444', '#7A7A7A',
                '#9E9E9E'
            ]
        };

        // ====================================================================
        // HELPERS
        // ====================================================================
        function toNum(n) {
            if (typeof n === 'bigint') return Number(n);
            if (n == null) return NaN;
            return Number(n);
        }

        function fmt(n) {
            const v = toNum(n);
            if (isNaN(v)) return '-';
            return v.toLocaleString('en-US', { maximumFractionDigits: 0 });
        }

        function fmtPct(n) {
            const v = toNum(n);
            if (isNaN(v)) return '-';
            return v.toFixed(1) + '%';
        }

        function fmtDuration(seconds) {
            const v = toNum(seconds);
            if (isNaN(v)) return '-';
            const m = Math.floor(v / 60);
            const s = Math.round(v % 60);
            return m > 0 ? `${m}m ${s}s` : `${s}s`;
        }

        function updateStatus(state, text) {
            const dot = document.getElementById('statusDot');
            const txt = document.getElementById('statusText');
            dot.className = 'status-dot' + (state === 'loading' ? ' loading' : state === 'error' ? ' error' : '');
            txt.textContent = text;
        }

        function setLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function destroyChart(id) {
            if (charts[id]) { charts[id].destroy(); delete charts[id]; }
        }

        function getWhereClause(col = 'date') {
            const parts = ['1=1'];
            if (dateFilter.from && dateFilter.to) {
                parts.push(`${col} >= '${dateFilter.from}' AND ${col} <= '${dateFilter.to}'`);
            }
            if (channelFilterValue.length > 0) {
                const list = channelFilterValue.map(c => `'${c.replace(/'/g, "''")}'`).join(',');
                parts.push(`channel IN (${list})`);
            }
            if (videoSearchValue.length >= 2) {
                parts.push(`name ILIKE '%${videoSearchValue.replace(/'/g, "''")}%'`);
            }
            return parts.join(' AND ');
        }

        function truncateStr(s, maxLen = 60) {
            if (!s) return '';
            return s.length > maxLen ? s.substring(0, maxLen) + '...' : s;
        }

        // Decode Arrow Decimal128 stored as Uint32Array(4) — little-endian 128-bit int
        function decodeDecimal128(arr, scale) {
            const lo = BigInt(arr[0]) | (BigInt(arr[1]) << 32n);
            const hi = BigInt(arr[2]) | (BigInt(arr[3]) << 32n);
            let val = lo | (hi << 64n);
            // Two's complement for negative values
            if (arr[3] & 0x80000000) val -= (1n << 128n);
            let num = Number(val);
            if (scale) num /= Math.pow(10, scale);
            return num;
        }

        function coerce(v, fieldType) {
            if (v == null) return null;
            if (typeof v === 'bigint') return Number(v);
            if (typeof v === 'number' || typeof v === 'string' || typeof v === 'boolean') return v;
            // Arrow Decimal128 → Uint32Array(4)
            if (v instanceof Uint32Array && v.length === 4) {
                return decodeDecimal128(v, fieldType?.scale);
            }
            // Other Arrow objects
            if (typeof v.valueOf === 'function') {
                const prim = v.valueOf();
                if (typeof prim === 'bigint') return Number(prim);
                if (typeof prim !== 'object') return prim;
            }
            const s = String(v);
            const n = Number(s);
            return isNaN(n) ? s : n;
        }

        async function query(sql) {
            const result = await conn.query(sql);
            const fields = result.schema.fields;
            const cols = fields.map(f => f.name);
            return result.toArray().map(row => {
                const obj = {};
                for (let i = 0; i < cols.length; i++) {
                    obj[cols[i]] = coerce(row[cols[i]], fields[i].type);
                }
                return obj;
            });
        }

        // ====================================================================
        // TAB NAVIGATION (lazy rendering)
        // ====================================================================
        function safeRender(fn) {
            return fn().catch(err => console.error(`Render error in ${fn.name || 'anonymous'}:`, err));
        }

        const tabRenderers = {
            overview: async () => {
                // Render above-the-fold content first (KPIs appear instantly)
                await Promise.all([
                    safeRender(renderExecutiveSummary), safeRender(renderKPIs)
                ]);
                // Then charts below the fold (non-blocking)
                Promise.all([
                    safeRender(renderMonthlyViews), safeRender(renderMonthlyEngagement),
                    safeRender(renderFunnel), safeRender(renderChannelViews)
                ]);
            },
            content: () => Promise.all([
                safeRender(renderContentTrends), safeRender(renderTopVideosByWatchHours),
                safeRender(renderDurationCompletion), safeRender(renderDurationViews),
                safeRender(renderTopVideosByViews), safeRender(renderTopVideosByEngagement),
                safeRender(renderLowPlayRate)
            ]),
            channels: () => Promise.all([
                safeRender(renderChannelTable), safeRender(renderChannelEfficiency),
                safeRender(renderChannelEngagement), safeRender(renderChannelFunnel)
            ]),
            devices: () => Promise.all([
                safeRender(renderDevicePie), safeRender(renderDeviceBar), safeRender(renderDeviceTrend)
            ]),
            regional: () => Promise.all([
                safeRender(renderGeoMap),
                safeRender(renderCountryViews), safeRender(renderCountryEngagement),
                safeRender(renderCountryBubble), safeRender(renderCountryTable),
                safeRender(renderCountryTopVideos)
            ]),
            lifecycle: () => Promise.all([
                safeRender(renderStaleContent), safeRender(renderRecentPerformers)
            ]),
            videotable: () => safeRender(renderVideoTable)
        };

        let renderedTabs = new Set();
        let activeTab = 'overview';

        async function renderTab(name) {
            if (tabRenderers[name]) {
                await tabRenderers[name]();
                renderedTabs.add(name);
            }
        }

        let dbReady = false;
        let dataRefreshTime = null;

        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', async () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.nav-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                activeTab = tab.dataset.nav;
                document.getElementById('nav-' + activeTab).classList.add('active');
                if (dbReady && !renderedTabs.has(activeTab)) {
                    await renderTab(activeTab);
                }
            });
        });

        // ====================================================================
        // INIT
        // ====================================================================
        async function init() {
            try {
                updateStatus('loading', 'Waiting for DuckDB...');

                if (!window.duckdb) {
                    await new Promise(resolve => {
                        window.addEventListener('duckdb-ready', resolve, { once: true });
                    });
                }

                updateStatus('loading', 'Initializing DuckDB...');
                setLoadingText('Initializing DuckDB...');

                const duckdbModule = window.duckdb;
                const JSDELIVR_BUNDLES = duckdbModule.getJsDelivrBundles();
                const bundle = await duckdbModule.selectBundle(JSDELIVR_BUNDLES);
                const worker_url = URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: 'text/javascript' })
                );
                const worker = new Worker(worker_url);
                const logger = new duckdbModule.ConsoleLogger();
                db = new duckdbModule.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                URL.revokeObjectURL(worker_url);

                conn = await db.connect();

                setLoadingText('Loading parquet files...');
                await loadParquetFiles();

                await setInitialDateRange();

                // Show dashboard shell immediately
                document.getElementById('loadingState').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';
                document.getElementById('navTabs').classList.remove('loading');
                document.getElementById('filterBar').classList.remove('loading');
                document.getElementById('dateFilterControls').classList.remove('loading');
                dbReady = true;

                // Render visible content first, run non-critical tasks in background
                await renderTab(activeTab);

                // Channel filter + refresh time in parallel, non-blocking
                Promise.all([
                    populateChannelFilter(),
                    (async () => {
                        try {
                            const refreshResult = await query(`SELECT MAX(report_generated_on) as last_refresh FROM facts`);
                            if (refreshResult[0]?.last_refresh) {
                                dataRefreshTime = new Date(refreshResult[0].last_refresh);
                            }
                        } catch (e) { /* ignore */ }
                        const refreshLabel = dataRefreshTime
                            ? `Data from: ${dataRefreshTime.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })} ${dataRefreshTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`
                            : `Loaded: ${new Date().toLocaleTimeString()}`;
                        updateStatus('success', refreshLabel);
                    })()
                ]);
            } catch (error) {
                console.error('Init error:', error);
                setLoadingText(`Failed to initialize: ${error.message}`);
                updateStatus('error', 'Error loading data');
            }
        }

        async function loadParquetFiles() {
            const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '');
            const pathsToTry = [
                `${baseUrl}/../output/parquet/`,
                `${window.location.origin}/output/parquet/`,
                `${baseUrl}/output/parquet/`
            ];

            // Discover the correct base path with a lightweight HEAD request
            let resolvedBase = null;
            for (const basePath of pathsToTry) {
                try {
                    const resp = await fetch(basePath + 'facts/daily_analytics_all.parquet', { method: 'HEAD' });
                    if (resp.ok) { resolvedBase = basePath; break; }
                } catch (e) { /* try next */ }
            }
            if (!resolvedBase) {
                // Fallback: try full fetch on first path
                resolvedBase = pathsToTry[0];
            }

            async function fetchAndRegister(fileName, relativePath, statusText) {
                const fullPath = resolvedBase + relativePath;
                setLoadingText(`Fetching ${fileName}...`);
                const response = await fetch(fullPath);
                if (!response.ok) throw new Error(`HTTP ${response.status} for ${relativePath}`);
                const buffer = await response.arrayBuffer();
                await db.registerFileBuffer(fileName, new Uint8Array(buffer));
                await conn.query(`CREATE VIEW ${fileName.replace('.parquet', '')} AS SELECT * FROM read_parquet('${fileName}')`);
                setLoadingText(statusText);
            }

            // Download both parquet files in parallel
            setLoadingText('Loading parquet files...');
            await Promise.all([
                fetchAndRegister('facts.parquet', 'facts/daily_analytics_all.parquet', 'Loaded daily analytics...'),
                fetchAndRegister('dims.parquet', 'dimensions/video_metadata.parquet', 'Loaded video metadata...')
            ]);

            // Create joined view for convenience
            setLoadingText('Creating analytics view...');
            await conn.query(`
                CREATE VIEW analytics AS
                SELECT
                    f.*,
                    d.channel,
                    d.name,
                    d.account_id,
                    d.video_duration,
                    COALESCE(d.video_duration_seconds, d.video_duration / 1000.0) as video_duration_seconds,
                    d.created_at,
                    d.published_at,
                    d.video_content_type,
                    d.video_category,
                    d.country,
                    d.language
                FROM facts f
                JOIN dims d ON f.video_id = d.video_id
            `);
        }

        async function setInitialDateRange() {
            const result = await query(`SELECT MIN(date) as min_date, MAX(date) as max_date FROM facts`);
            const row = result[0];
            const minDate = new Date(row.min_date);
            const maxDate = new Date(row.max_date);

            const fmtDate = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            document.getElementById('dateFrom').value = fmtDate(minDate);
            document.getElementById('dateTo').value = fmtDate(maxDate);

            dateFilter.from = document.getElementById('dateFrom').value;
            dateFilter.to = document.getElementById('dateTo').value;
        }

        async function applyDateFilter() {
            dateFilter.from = document.getElementById('dateFrom').value;
            dateFilter.to = document.getElementById('dateTo').value;
            if (dateFilter.from && dateFilter.to) {
                clearPresetActive();
                updateActiveFilters();
                await renderDashboard();
            }
        }

        async function applyDatePreset(preset) {
            const today = new Date();
            let from, to;

            switch (preset) {
                case '7d':
                    to = today;
                    from = new Date(today);
                    from.setDate(from.getDate() - 6);
                    break;
                case '30d':
                    to = today;
                    from = new Date(today);
                    from.setDate(from.getDate() - 29);
                    break;
                case 'this-month':
                    from = new Date(today.getFullYear(), today.getMonth(), 1);
                    to = today;
                    break;
                case 'last-month':
                    from = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    to = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
                case 'ytd':
                    from = new Date(today.getFullYear(), 0, 1);
                    to = today;
                    break;
                case 'last-year':
                    from = new Date(today.getFullYear() - 1, 0, 1);
                    to = new Date(today.getFullYear() - 1, 11, 31);
                    break;
                case 'all':
                    await setInitialDateRange();
                    clearPresetActive();
                    document.querySelector(`.date-preset[data-preset="all"]`).classList.add('active');
                    updateActiveFilters();
                    await renderDashboard();
                    return;
            }

            const fmt = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
            document.getElementById('dateFrom').value = fmt(from);
            document.getElementById('dateTo').value = fmt(to);
            dateFilter.from = fmt(from);
            dateFilter.to = fmt(to);

            clearPresetActive();
            document.querySelector(`.date-preset[data-preset="${preset}"]`).classList.add('active');
            updateActiveFilters();
            await renderDashboard();
        }

        function clearPresetActive() {
            document.querySelectorAll('.date-preset').forEach(b => b.classList.remove('active'));
        }

        async function resetDateFilter() {
            await setInitialDateRange();
            channelFilterValue = [];
            videoSearchValue = '';
            document.getElementById('videoSearch').value = '';
            updateChannelToggleLabel();
            uncheckAllChannels();
            clearPresetActive();
            updateActiveFilters();
            await renderDashboard();
        }

        async function applyFilters() {
            videoSearchValue = document.getElementById('videoSearch').value.trim();
            updateActiveFilters();
            await renderDashboard();
        }

        function debounceApplyFilters() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => applyFilters(), 400);
        }

        // Video search autocomplete
        let acTimer = null;
        let acIndex = -1;

        function onVideoSearchInput() {
            clearTimeout(acTimer);
            const val = document.getElementById('videoSearch').value.trim();
            if (val.length < 2) {
                closeAutocomplete();
                debounceApplyFilters();
                return;
            }
            acTimer = setTimeout(async () => {
                const results = await query(`
                    SELECT DISTINCT name, channel
                    FROM dims
                    WHERE name ILIKE '%${val.replace(/'/g, "''")}%'
                    ORDER BY name
                    LIMIT 15
                `);
                showAutocomplete(results, val);
                debounceApplyFilters();
            }, 200);
        }

        function showAutocomplete(results, term) {
            const list = document.getElementById('videoAutocomplete');
            if (!results || results.length === 0) {
                closeAutocomplete();
                return;
            }
            const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            list.innerHTML = results.map((r, i) => {
                const highlighted = r.name.replace(regex, '<mark>$1</mark>');
                return `<div class="autocomplete-item" data-index="${i}" onmousedown="selectAutocomplete('${r.name.replace(/'/g, "\\'")}')">${highlighted}<span class="channel-hint">${r.channel}</span></div>`;
            }).join('');
            acIndex = -1;
            list.classList.add('open');
        }

        function closeAutocomplete() {
            document.getElementById('videoAutocomplete').classList.remove('open');
            acIndex = -1;
        }

        function selectAutocomplete(name) {
            document.getElementById('videoSearch').value = name;
            closeAutocomplete();
            applyFilters();
        }

        function onVideoSearchKeydown(e) {
            const list = document.getElementById('videoAutocomplete');
            const items = list.querySelectorAll('.autocomplete-item');
            if (!list.classList.contains('open') || items.length === 0) {
                if (e.key === 'Enter') { e.preventDefault(); applyFilters(); }
                return;
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                acIndex = Math.min(acIndex + 1, items.length - 1);
                updateAcHighlight(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                acIndex = Math.max(acIndex - 1, 0);
                updateAcHighlight(items);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (acIndex >= 0 && acIndex < items.length) {
                    items[acIndex].onmousedown();
                } else {
                    closeAutocomplete();
                    applyFilters();
                }
            } else if (e.key === 'Escape') {
                closeAutocomplete();
            }
        }

        function updateAcHighlight(items) {
            items.forEach((it, i) => it.classList.toggle('active', i === acIndex));
            if (acIndex >= 0) items[acIndex].scrollIntoView({ block: 'nearest' });
        }

        // Close autocomplete when clicking outside
        document.addEventListener('click', (e) => {
            const wrapper = document.querySelector('.autocomplete-wrapper');
            if (wrapper && !wrapper.contains(e.target)) closeAutocomplete();
        });

        // Channel multi-select
        function toggleChannelDropdown() {
            const dd = document.getElementById('channelDropdown');
            const toggle = dd.previousElementSibling;
            const isOpen = dd.classList.toggle('open');
            toggle.classList.toggle('open', isOpen);
            if (isOpen) {
                const input = document.getElementById('channelSearchInput');
                input.value = '';
                renderChannelOptions();
                setTimeout(() => input.focus(), 50);
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const ms = document.getElementById('channelMultiSelect');
            if (ms && !ms.contains(e.target)) {
                document.getElementById('channelDropdown').classList.remove('open');
                document.querySelector('.multi-select-toggle').classList.remove('open');
                document.getElementById('channelSearchInput').value = '';
                renderChannelOptions();
            }
        });

        function onChannelSelectAll() {
            const selectAll = document.getElementById('channelSelectAll');
            const boxes = document.querySelectorAll('#channelDropdown input[type="checkbox"][value]');
            boxes.forEach(cb => cb.checked = selectAll.checked);
            // All checked = no filter (show everything)
            channelFilterValue = [];
            updateChannelToggleLabel();
            updateActiveFilters();
            renderDashboard();
        }

        function onChannelCheckboxChange() {
            const boxes = document.querySelectorAll('#channelDropdown input[type="checkbox"][value]');
            const checked = Array.from(boxes).filter(cb => cb.checked);
            const selectAll = document.getElementById('channelSelectAll');

            if (checked.length === allChannels.length) {
                // All individually checked = same as "All Channels"
                selectAll.checked = true;
                channelFilterValue = [];
            } else {
                selectAll.checked = false;
                channelFilterValue = checked.map(cb => cb.value);
            }
            updateChannelToggleLabel();
            updateActiveFilters();
            renderDashboard();
        }

        function updateChannelToggleLabel() {
            const label = document.getElementById('channelToggleLabel');
            if (channelFilterValue.length === 0) {
                label.textContent = 'All Channels';
            } else if (channelFilterValue.length === 1) {
                label.textContent = channelFilterValue[0];
            } else {
                label.textContent = `${channelFilterValue.length} channels`;
            }
        }

        function uncheckAllChannels() {
            document.querySelectorAll('#channelDropdown input[type="checkbox"]').forEach(cb => cb.checked = true);
        }

        function updateActiveFilters() {
            const el = document.getElementById('activeFilters');
            const tags = [];
            if (channelFilterValue.length > 0) {
                channelFilterValue.forEach(ch => {
                    tags.push(`<span class="filter-tag">${ch} <span class="remove" onclick="removeChannelFilter('${ch.replace(/'/g, "\\'")}')">x</span></span>`);
                });
            }
            if (videoSearchValue.length >= 2) {
                tags.push(`<span class="filter-tag">"${videoSearchValue}" <span class="remove" onclick="clearFilter('video')">x</span></span>`);
            }
            el.innerHTML = tags.join('');
        }

        async function removeChannelFilter(ch) {
            channelFilterValue = channelFilterValue.filter(c => c !== ch);
            const cb = document.querySelector(`#channelDropdown input[value="${CSS.escape(ch)}"]`);
            if (cb) cb.checked = false;
            const selectAll = document.getElementById('channelSelectAll');
            if (selectAll) selectAll.checked = channelFilterValue.length === 0;
            updateChannelToggleLabel();
            updateActiveFilters();
            await renderDashboard();
        }

        async function clearFilter(type) {
            if (type === 'channel') {
                channelFilterValue = [];
                uncheckAllChannels();
                updateChannelToggleLabel();
            } else if (type === 'video') {
                videoSearchValue = '';
                document.getElementById('videoSearch').value = '';
            }
            updateActiveFilters();
            await renderDashboard();
        }

        // ====================================================================
        // RENDER DASHBOARD
        // ====================================================================
        async function renderDashboard() {
            updateStatus('loading', 'Refreshing...');
            try {
                // Invalidate all tabs so they re-render on next visit
                renderedTabs.clear();
                // Render active tab (primary), channel filter in background
                populateChannelFilter();
                await renderTab(activeTab);
                const refreshLabel = dataRefreshTime
                    ? `Data from: ${dataRefreshTime.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })} ${dataRefreshTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`
                    : `Updated: ${new Date().toLocaleTimeString()}`;
                updateStatus('success', refreshLabel);
            } catch (error) {
                console.error('Render error:', error);
                updateStatus('error', 'Error rendering dashboard');
            }
        }

        // ====================================================================
        // EXECUTIVE SUMMARY
        // ====================================================================
        async function renderExecutiveSummary() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    SUM(video_view) as total_views,
                    COUNT(DISTINCT video_id) as total_videos,
                    COUNT(DISTINCT channel) as total_channels
                FROM analytics
                WHERE ${w}
            `);

            const engData = await query(`
                SELECT
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as avg_completion,
                    ROUND(SUM(views_mobile) * 100.0 / NULLIF(SUM(video_view), 0), 1) as mobile_pct
                FROM analytics
                WHERE ${w}            `);

            const row = data[0];
            const eng = engData[0];

            const insights = [];

            if (row.total_views > 0) {
                insights.push({
                    cls: 'positive',
                    title: 'Scale',
                    text: `${fmt(row.total_views)} total views across ${fmt(row.total_videos)} videos on ${row.total_channels} channels.`
                });
            }

            if (eng.avg_completion != null) {
                const cls = eng.avg_completion > 50 ? 'positive' : eng.avg_completion > 30 ? 'warning' : 'negative';
                insights.push({
                    cls,
                    title: 'Completion Rate',
                    text: `${fmtPct(eng.avg_completion)} of viewers watch videos to the end.`
                });
            }

            if (eng.mobile_pct != null) {
                insights.push({
                    cls: eng.mobile_pct > 30 ? 'warning' : '',
                    title: 'Mobile Viewing',
                    text: `${fmtPct(eng.mobile_pct)} of views come from mobile devices.${eng.mobile_pct > 30 ? ' Consider mobile-optimized content.' : ''}`
                });
            }

            const el = document.getElementById('executiveSummary');
            el.innerHTML = `
                <div class="executive-summary">
                    <div class="summary-title">Executive Summary</div>
                    <div class="insights-grid">
                        ${insights.map(i => `
                            <div class="insight-card ${i.cls}">
                                <div class="insight-title">${i.title}</div>
                                <div class="insight-text">${i.text}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // ====================================================================
        // KPIs
        // ====================================================================
        async function renderKPIs() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    SUM(video_view) as total_views,
                    COUNT(DISTINCT video_id) as total_videos,
                    COUNT(DISTINCT channel) as total_channels,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 0) as watch_hours,
                    SUM(video_impression) as total_impressions
                FROM analytics
                WHERE ${w}
            `);

            const engData = await query(`
                SELECT
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion_rate,
                    ROUND(SUM(video_engagement_25) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_25
                FROM analytics
                WHERE ${w}            `);

            const libData = await query(`
                SELECT
                    COUNT(DISTINCT video_id) as total_library,
                    COUNT(DISTINCT CASE WHEN video_view > 0 THEN video_id END) as viewed_videos
                FROM analytics
                WHERE ${w}            `);

            const row = data[0];
            const eng = engData[0];
            const lib = libData[0];
            const libraryPct = lib.total_library > 0 ? (lib.viewed_videos * 100.0 / lib.total_library).toFixed(1) : 0;

            document.getElementById('kpiCards').innerHTML = `
                <div class="kpi-card highlight">
                    <div class="kpi-label">Total Views</div>
                    <div class="kpi-value">${fmt(row.total_views)}</div>
                </div>
                <div class="kpi-card info">
                    <div class="kpi-label">Videos Tracked</div>
                    <div class="kpi-value">${fmt(row.total_videos)}</div>
                </div>
                <div class="kpi-card info">
                    <div class="kpi-label">Channels</div>
                    <div class="kpi-value">${row.total_channels}</div>
                </div>
                <div class="kpi-card success">
                    <div class="kpi-label">Watch Hours</div>
                    <div class="kpi-value">${fmt(row.watch_hours)}</div>
                </div>
                <div class="kpi-card warning">
                    <div class="kpi-label">Impressions</div>
                    <div class="kpi-value">${fmt(row.total_impressions)}</div>
                </div>
                <div class="kpi-card ${eng.completion_rate > 50 ? 'success' : 'warning'}">
                    <div class="kpi-label">Completion Rate</div>
                    <div class="kpi-value">${fmtPct(eng.completion_rate)}</div>
                </div>
                <div class="kpi-card info">
                    <div class="kpi-label">Library Viewed</div>
                    <div class="kpi-value">${libraryPct}%</div>
                    <div class="kpi-subtitle">${fmt(lib.viewed_videos)} of ${fmt(lib.total_library)} videos</div>
                </div>
            `;
        }

        // ====================================================================
        // MONTHLY VIEWS
        // ====================================================================
        async function renderMonthlyViews() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    DATE_TRUNC('month', date)::VARCHAR as month,
                    SUM(video_view) as views
                FROM analytics
                WHERE ${w}
                  AND DATE_TRUNC('month', date) < DATE_TRUNC('month', CURRENT_DATE)
                GROUP BY 1 ORDER BY 1
            `);

            destroyChart('chartMonthlyViews');
            const ctx = document.getElementById('chartMonthlyViews').getContext('2d');
            charts['chartMonthlyViews'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.month.substring(0, 7)),
                    datasets: [{
                        data: data.map(r => r.views),
                        backgroundColor: COLORS.chartLight,
                        borderColor: COLORS.chart,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, ticks: { callback: v => fmt(v) } },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }

        // ====================================================================
        // MONTHLY ENGAGEMENT
        // ====================================================================
        async function renderMonthlyEngagement() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    DATE_TRUNC('month', date)::VARCHAR as month,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion,
                    ROUND(SUM(video_engagement_50) * 100.0 / NULLIF(SUM(video_view), 0), 1) as halfway
                FROM analytics
                WHERE ${w}
                                   AND DATE_TRUNC('month', date) < DATE_TRUNC('month', CURRENT_DATE)
                GROUP BY 1 ORDER BY 1
            `);

            destroyChart('chartMonthlyEngagement');
            const ctx = document.getElementById('chartMonthlyEngagement').getContext('2d');
            charts['chartMonthlyEngagement'] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(r => r.month.substring(0, 7)),
                    datasets: [
                        {
                            label: 'Reached 50%',
                            data: data.map(r => r.halfway),
                            borderColor: COLORS.warning,
                            backgroundColor: COLORS.warning + '20',
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'Completed',
                            data: data.map(r => r.completion),
                            borderColor: COLORS.success,
                            backgroundColor: COLORS.success + '20',
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'top' } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }

        // ====================================================================
        // ENGAGEMENT FUNNEL
        // ====================================================================
        async function renderFunnel() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    ROUND(SUM(video_engagement_1) * 100.0 / NULLIF(SUM(video_view), 0), 1) as started,
                    ROUND(SUM(video_engagement_25) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_25,
                    ROUND(SUM(video_engagement_50) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_50,
                    ROUND(SUM(video_engagement_75) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_75,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completed
                FROM analytics
                WHERE ${w}            `);

            const row = data[0];
            const labels = ['Completed (100%)', 'Reached 75%', 'Reached 50%', 'Reached 25%', 'Started (1%)'];
            const values = [row.completed, row.reached_75, row.reached_50, row.reached_25, row.started];
            const colors = ['#333333', '#555555', '#777777', '#999999', '#BBBBBB'];

            destroyChart('chartFunnel');
            const ctx = document.getElementById('chartFunnel').getContext('2d');
            charts['chartFunnel'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: colors.reverse(),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { label: ctx => fmtPct(ctx.raw) } }
                    },
                    scales: {
                        x: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } }
                    }
                }
            });
        }

        // ====================================================================
        // CHANNEL VIEWS (Overview)
        // ====================================================================
        async function renderChannelViews() {
            const w = getWhereClause();
            const data = await query(`
                SELECT channel, SUM(video_view) as views
                FROM analytics
                WHERE ${w}
                GROUP BY channel
                ORDER BY views DESC
            `);

            destroyChart('chartChannelViews');
            const ctx = document.getElementById('chartChannelViews').getContext('2d');
            charts['chartChannelViews'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.channel),
                    datasets: [{
                        data: data.map(r => r.views),
                        backgroundColor: data.map((_, i) => COLORS.palette[i % COLORS.palette.length] + '99'),
                        borderColor: data.map((_, i) => COLORS.palette[i % COLORS.palette.length]),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { beginAtZero: true, ticks: { callback: v => fmt(v) } }
                    }
                }
            });
        }

        // ====================================================================
        // DURATION SWEET SPOT
        // ====================================================================
        async function renderDurationCompletion() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    CASE
                        WHEN video_duration_seconds <= 60 THEN '0-1 min'
                        WHEN video_duration_seconds <= 120 THEN '1-2 min'
                        WHEN video_duration_seconds <= 180 THEN '2-3 min'
                        WHEN video_duration_seconds <= 300 THEN '3-5 min'
                        WHEN video_duration_seconds <= 600 THEN '5-10 min'
                        WHEN video_duration_seconds <= 900 THEN '10-15 min'
                        ELSE '15+ min'
                    END as bucket,
                    CASE
                        WHEN video_duration_seconds <= 60 THEN 1
                        WHEN video_duration_seconds <= 120 THEN 2
                        WHEN video_duration_seconds <= 180 THEN 3
                        WHEN video_duration_seconds <= 300 THEN 4
                        WHEN video_duration_seconds <= 600 THEN 5
                        WHEN video_duration_seconds <= 900 THEN 6
                        ELSE 7
                    END as sort_order,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_duration_seconds > 0 AND video_view > 0                GROUP BY 1, 2 ORDER BY sort_order
            `);

            destroyChart('chartDurationCompletion');
            const ctx = document.getElementById('chartDurationCompletion').getContext('2d');
            charts['chartDurationCompletion'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.bucket),
                    datasets: [{
                        data: data.map(r => r.completion),
                        backgroundColor: data.map(r => r.completion > 50 ? COLORS.success + '99' : r.completion > 30 ? COLORS.warning + '99' : COLORS.danger + '99'),
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { label: ctx => fmtPct(ctx.raw) } }
                    },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }

        async function renderDurationViews() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    CASE
                        WHEN video_duration_seconds <= 60 THEN '0-1 min'
                        WHEN video_duration_seconds <= 120 THEN '1-2 min'
                        WHEN video_duration_seconds <= 180 THEN '2-3 min'
                        WHEN video_duration_seconds <= 300 THEN '3-5 min'
                        WHEN video_duration_seconds <= 600 THEN '5-10 min'
                        WHEN video_duration_seconds <= 900 THEN '10-15 min'
                        ELSE '15+ min'
                    END as bucket,
                    CASE
                        WHEN video_duration_seconds <= 60 THEN 1
                        WHEN video_duration_seconds <= 120 THEN 2
                        WHEN video_duration_seconds <= 180 THEN 3
                        WHEN video_duration_seconds <= 300 THEN 4
                        WHEN video_duration_seconds <= 600 THEN 5
                        WHEN video_duration_seconds <= 900 THEN 6
                        ELSE 7
                    END as sort_order,
                    SUM(video_view) as views,
                    COUNT(DISTINCT video_id) as num_videos
                FROM analytics
                WHERE ${w} AND video_duration_seconds > 0 AND video_view > 0
                GROUP BY 1, 2 ORDER BY sort_order
            `);

            destroyChart('chartDurationViews');
            const ctx = document.getElementById('chartDurationViews').getContext('2d');
            charts['chartDurationViews'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.bucket),
                    datasets: [{
                        label: 'Views',
                        data: data.map(r => r.views),
                        backgroundColor: COLORS.chartLight,
                        borderColor: COLORS.chart,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                afterLabel: (ctx) => `${fmt(data[ctx.dataIndex].num_videos)} videos`
                            }
                        }
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { callback: v => fmt(v) } },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }

        // ====================================================================
        // CONTENT TRENDS (weekly hours viewed for top videos)
        // ====================================================================
        async function renderContentTrends() {
            const w = getWhereClause();
            // Find top 10 videos by total watch hours
            const topVideos = await query(`
                SELECT video_id, MAX(name) as name,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 1) as hours
                FROM analytics
                WHERE ${w} AND video_seconds_viewed > 0
                GROUP BY video_id
                ORDER BY hours DESC
                LIMIT 10
            `);

            if (topVideos.length === 0) {
                destroyChart('chartContentTrends');
                return;
            }

            const videoIds = topVideos.map(v => `'${v.video_id}'`).join(',');
            const weekly = await query(`
                SELECT
                    video_id,
                    DATE_TRUNC('week', date)::VARCHAR as week,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 2) as hours
                FROM analytics
                WHERE ${w} AND video_id IN (${videoIds})
                  AND DATE_TRUNC('week', date) < DATE_TRUNC('week', CURRENT_DATE)
                GROUP BY video_id, 2
                ORDER BY 2
            `);

            // Build unique sorted weeks
            const weeks = [...new Set(weekly.map(r => r.week.substring(0, 10)))].sort();

            // Build datasets
            const datasets = topVideos.map((v, i) => {
                const videoWeeks = weekly.filter(r => r.video_id === v.video_id);
                const weekMap = {};
                videoWeeks.forEach(r => weekMap[r.week.substring(0, 10)] = r.hours);
                return {
                    label: truncateStr(v.name, 40),
                    data: weeks.map(w => weekMap[w] || 0),
                    borderColor: COLORS.palette[i % COLORS.palette.length],
                    backgroundColor: COLORS.palette[i % COLORS.palette.length] + '20',
                    tension: 0.3,
                    pointRadius: 1,
                    borderWidth: 2
                };
            });

            destroyChart('chartContentTrends');
            const ctx = document.getElementById('chartContentTrends').getContext('2d');
            charts['chartContentTrends'] = new Chart(ctx, {
                type: 'line',
                data: { labels: weeks, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12, font: { size: 10 } } },
                        tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(1)}h` } }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Hours viewed' } },
                        x: { ticks: { maxRotation: 45, maxTicksLimit: 20 } }
                    }
                }
            });
        }

        // ====================================================================
        // TOP VIDEOS BY WATCH HOURS
        // ====================================================================
        async function renderTopVideosByWatchHours() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    video_id,
                    MAX(name) as name,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 1) as watch_hours,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_seconds_viewed > 0
                GROUP BY channel, video_id
                ORDER BY watch_hours DESC
                LIMIT 20
            `);

            document.getElementById('topVideosByWatchHours').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'watch_hours', label: 'Watch Hours', cls: 'text-right', fmt: v => v != null ? Number(v).toFixed(1) : '-' },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // TOP VIDEOS BY VIEWS
        // ====================================================================
        async function renderTopVideosByViews() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    video_id,
                    MAX(name) as name,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY channel, video_id
                ORDER BY views DESC
                LIMIT 20
            `);

            document.getElementById('topVideosByViews').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // TOP VIDEOS BY ENGAGEMENT
        // ====================================================================
        async function renderTopVideosByEngagement() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    video_id,
                    MAX(name) as name,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion,
                    ROUND(SUM(video_engagement_50) * 100.0 / NULLIF(SUM(video_view), 0), 1) as halfway
                FROM analytics
                WHERE ${w} AND video_view > 0                GROUP BY channel, video_id
                HAVING SUM(video_view) >= 100
                ORDER BY completion DESC
                LIMIT 20
            `);

            document.getElementById('topVideosByEngagement').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'halfway', label: 'Reached 50%', cls: 'text-right', fmt: fmtPct },
                { key: 'completion', label: 'Completed', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // LOW PLAY RATE VIDEOS
        // ====================================================================
        async function renderLowPlayRate() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    video_id,
                    MAX(name) as name,
                    SUM(video_impression) as impressions,
                    SUM(video_view) as views,
                    ROUND(SUM(video_view) * 100.0 / NULLIF(SUM(video_impression), 0), 1) as play_rate
                FROM analytics
                WHERE ${w} AND video_impression > 0
                GROUP BY channel, video_id
                HAVING SUM(video_impression) >= 100
                ORDER BY play_rate ASC
                LIMIT 20
            `);

            document.getElementById('lowPlayRate').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'impressions', label: 'Impressions', cls: 'text-right', fmt: fmt },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'play_rate', label: 'Play Rate', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // CHANNEL TABLE
        // ====================================================================
        async function renderChannelTable() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    COUNT(DISTINCT video_id) as num_videos,
                    SUM(video_view) as views,
                    ROUND(SUM(video_view) * 1.0 / NULLIF(COUNT(DISTINCT video_id), 0), 0) as views_per_video,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion,
                    ROUND(SUM(views_mobile) * 100.0 / NULLIF(SUM(video_view), 0), 1) as mobile_pct
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY channel
                ORDER BY views DESC
            `);

            document.getElementById('channelTable').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'num_videos', label: 'Videos', cls: 'text-right', fmt: fmt },
                { key: 'views', label: 'Total Views', cls: 'text-right', fmt: fmt },
                { key: 'views_per_video', label: 'Views/Video', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct },
                { key: 'mobile_pct', label: 'Mobile %', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // CHANNEL EFFICIENCY CHART
        // ====================================================================
        async function renderChannelEfficiency() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    ROUND(SUM(video_view) * 1.0 / NULLIF(COUNT(DISTINCT video_id), 0), 0) as views_per_video
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY channel
                ORDER BY views_per_video DESC
            `);

            destroyChart('chartChannelEfficiency');
            const ctx = document.getElementById('chartChannelEfficiency').getContext('2d');
            charts['chartChannelEfficiency'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.channel),
                    datasets: [{
                        data: data.map(r => r.views_per_video),
                        backgroundColor: data.map((_, i) => COLORS.palette[i % COLORS.palette.length] + '99'),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { beginAtZero: true, ticks: { callback: v => fmt(v) } }
                    }
                }
            });
        }

        // ====================================================================
        // CHANNEL ENGAGEMENT CHART
        // ====================================================================
        async function renderChannelEngagement() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_view > 0                GROUP BY channel
                ORDER BY completion DESC
            `);

            destroyChart('chartChannelEngagement');
            const ctx = document.getElementById('chartChannelEngagement').getContext('2d');
            charts['chartChannelEngagement'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.channel),
                    datasets: [{
                        data: data.map(r => r.completion),
                        backgroundColor: data.map(r => r.completion > 50 ? COLORS.success + '99' : r.completion > 30 ? COLORS.warning + '99' : COLORS.danger + '99'),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { callbacks: { label: ctx => fmtPct(ctx.raw) } }
                    },
                    scales: {
                        x: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } }
                    }
                }
            });
        }

        // ====================================================================
        // CHANNEL FUNNEL TABLE
        // ====================================================================
        async function renderChannelFunnel() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    channel,
                    ROUND(SUM(video_engagement_1) * 100.0 / NULLIF(SUM(video_view), 0), 1) as started,
                    ROUND(SUM(video_engagement_25) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_25,
                    ROUND(SUM(video_engagement_50) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_50,
                    ROUND(SUM(video_engagement_75) * 100.0 / NULLIF(SUM(video_view), 0), 1) as reached_75,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completed
                FROM analytics
                WHERE ${w} AND video_view > 0                GROUP BY channel
                ORDER BY completed DESC
            `);

            document.getElementById('channelFunnelTable').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'started', label: 'Started', cls: 'text-right', fmt: fmtPct },
                { key: 'reached_25', label: '25%', cls: 'text-right', fmt: fmtPct },
                { key: 'reached_50', label: '50%', cls: 'text-right', fmt: fmtPct },
                { key: 'reached_75', label: '75%', cls: 'text-right', fmt: fmtPct },
                { key: 'completed', label: '100%', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // DEVICE PIE
        // ====================================================================
        async function renderDevicePie() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    SUM(views_desktop) as desktop,
                    SUM(views_mobile) as mobile,
                    SUM(views_tablet) as tablet,
                    SUM(views_other) as other_device
                FROM analytics
                WHERE ${w}
            `);

            const row = data[0];
            const labels = [];
            const values = [];
            const colors = ['#444444', '#777777', '#AAAAAA', '#CCCCCC'];

            if (row.desktop > 0) { labels.push('Desktop'); values.push(row.desktop); }
            if (row.mobile > 0) { labels.push('Mobile'); values.push(row.mobile); }
            if (row.tablet > 0) { labels.push('Tablet'); values.push(row.tablet); }
            if (row.other_device > 0) { labels.push('Other'); values.push(row.other_device); }

            destroyChart('chartDevicePie');
            const ctx = document.getElementById('chartDevicePie').getContext('2d');
            charts['chartDevicePie'] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: colors.slice(0, values.length),
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right' },
                        tooltip: {
                            callbacks: {
                                label: ctx => {
                                    const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                    const pct = (ctx.raw / total * 100).toFixed(1);
                                    return `${ctx.label}: ${fmt(ctx.raw)} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // ====================================================================
        // DEVICE BAR
        // ====================================================================
        async function renderDeviceBar() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    SUM(views_desktop) as desktop,
                    SUM(views_mobile) as mobile,
                    SUM(views_tablet) as tablet,
                    SUM(views_other) as other_device
                FROM analytics
                WHERE ${w}
            `);

            const row = data[0];
            const entries = [
                { label: 'Desktop', value: row.desktop },
                { label: 'Mobile', value: row.mobile },
                { label: 'Tablet', value: row.tablet },
                { label: 'Other', value: row.other_device }
            ].filter(e => e.value > 0);

            destroyChart('chartDeviceBar');
            const ctx = document.getElementById('chartDeviceBar').getContext('2d');
            charts['chartDeviceBar'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: entries.map(e => e.label),
                    datasets: [{
                        data: entries.map(e => e.value),
                        backgroundColor: ['#44444499', '#77777799', '#AAAAAA99', '#CCCCCC99'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, ticks: { callback: v => fmt(v) } }
                    }
                }
            });
        }

        // ====================================================================
        // DEVICE TREND
        // ====================================================================
        async function renderDeviceTrend() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    DATE_TRUNC('month', date)::VARCHAR as month,
                    ROUND(SUM(views_desktop) * 100.0 / NULLIF(SUM(views_desktop) + SUM(views_mobile) + SUM(views_tablet), 0), 1) as desktop_pct,
                    ROUND(SUM(views_mobile) * 100.0 / NULLIF(SUM(views_desktop) + SUM(views_mobile) + SUM(views_tablet), 0), 1) as mobile_pct
                FROM analytics
                WHERE ${w}
                  AND DATE_TRUNC('month', date) < DATE_TRUNC('month', CURRENT_DATE)
                GROUP BY 1 ORDER BY 1
            `);

            destroyChart('chartDeviceTrend');
            const ctx = document.getElementById('chartDeviceTrend').getContext('2d');
            charts['chartDeviceTrend'] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(r => r.month.substring(0, 7)),
                    datasets: [
                        {
                            label: 'Desktop %',
                            data: data.map(r => r.desktop_pct),
                            borderColor: '#444444',
                            tension: 0.3,
                            pointRadius: 3
                        },
                        {
                            label: 'Mobile %',
                            data: data.map(r => r.mobile_pct),
                            borderColor: '#999999',
                            tension: 0.3,
                            pointRadius: 3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'top' } },
                    scales: {
                        y: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }

        // ====================================================================
        // REGIONAL: INTERACTIVE MAP
        // ====================================================================
        let worldTopology = null;
        let usTopology = null;
        let currentMapLevel = 'world';
        let geoMapChart = null;
        let geoRegistered = false;
        let mapZoomLevel = 1;

        function mapZoomIn() {
            mapZoomLevel = Math.min(mapZoomLevel * 1.4, 8);
            applyMapZoom();
        }
        function mapZoomOut() {
            mapZoomLevel = Math.max(mapZoomLevel / 1.4, 0.5);
            applyMapZoom();
        }
        function applyMapZoom() {
            if (!geoMapChart) return;
            geoMapChart.options.scales.projection.projectionScale = mapZoomLevel;
            geoMapChart.update();
        }

        function ensureGeoRegistered() {
            if (geoRegistered) return;
            if (typeof ChartGeo !== 'undefined') {
                Chart.register(
                    ChartGeo.ChoroplethController,
                    ChartGeo.GeoFeature,
                    ChartGeo.ColorScale,
                    ChartGeo.ProjectionScale
                );
                geoRegistered = true;
            }
        }

        // Country name mapping: data values → TopoJSON feature names
        const COUNTRY_NAME_MAP = {
            'US': 'United States of America', 'USA': 'United States of America',
            'United States': 'United States of America',
            'UK': 'United Kingdom', 'Great Britain': 'United Kingdom', 'England': 'United Kingdom',
            'Deutschland': 'Germany', 'DE': 'Germany',
            'Schweiz': 'Switzerland', 'Suisse': 'Switzerland', 'CH': 'Switzerland',
            'JP': 'Japan', 'FR': 'France', 'CN': 'China', 'IN': 'India',
            'BR': 'Brazil', 'RU': 'Russia', 'AU': 'Australia', 'CA': 'Canada',
            'IT': 'Italy', 'ES': 'Spain', 'KR': 'South Korea', 'MX': 'Mexico',
            'NL': 'Netherlands', 'AT': 'Austria', 'BE': 'Belgium',
            'SE': 'Sweden', 'NO': 'Norway', 'DK': 'Denmark', 'FI': 'Finland',
            'PL': 'Poland', 'CZ': 'Czechia', 'Czech Republic': 'Czechia',
            'SG': 'Singapore', 'HK': 'Hong Kong', 'TW': 'Taiwan',
            'IE': 'Ireland', 'NZ': 'New Zealand', 'ZA': 'South Africa',
            'AE': 'United Arab Emirates', 'UAE': 'United Arab Emirates',
            'LU': 'Luxembourg', 'PT': 'Portugal', 'LI': 'Liechtenstein',
        };

        function normalizeToFeatureName(name) {
            return COUNTRY_NAME_MAP[name] || name;
        }

        // Build reverse map: feature name → possible data country values
        function getDataCountryNames(featureName) {
            const names = [featureName];
            for (const [k, v] of Object.entries(COUNTRY_NAME_MAP)) {
                if (v === featureName) names.push(k);
            }
            return names;
        }

        async function loadWorldTopology() {
            if (worldTopology) return worldTopology;
            const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
            worldTopology = await resp.json();
            return worldTopology;
        }

        async function loadUSTopology() {
            if (usTopology) return usTopology;
            const resp = await fetch('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json');
            usTopology = await resp.json();
            return usTopology;
        }

        async function renderGeoMap() {
            ensureGeoRegistered();
            currentMapLevel = 'world';
            mapZoomLevel = 1;
            updateMapBreadcrumb();
            await renderWorldMap();
        }

        async function renderWorldMap() {
            const topo = await loadWorldTopology();
            const w = getWhereClause();

            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    ROUND(SUM(video_seconds_viewed) / 60.0, 0) as minutes_viewed
                FROM analytics
                WHERE ${w} AND video_seconds_viewed > 0
                GROUP BY 1
                ORDER BY minutes_viewed DESC
            `);

            // Build lookup: normalized feature name → minutes
            const minutesByFeature = {};
            data.forEach(r => {
                const featureName = normalizeToFeatureName(r.country);
                minutesByFeature[featureName] = (minutesByFeature[featureName] || 0) + r.minutes_viewed;
            });

            const countries = ChartGeo.topojson.feature(topo, topo.objects.countries).features;

            const chartData = countries.map(f => ({
                feature: f,
                value: minutesByFeature[f.properties.name] || 0
            }));

            if (geoMapChart) { geoMapChart.destroy(); geoMapChart = null; }

            const ctx = document.getElementById('chartGeoMap').getContext('2d');
            geoMapChart = new Chart(ctx, {
                type: 'choropleth',
                data: {
                    labels: countries.map(f => f.properties.name),
                    datasets: [{
                        label: 'Minutes Viewed',
                        outline: countries,
                        data: chartData,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (item) => {
                                    const name = item.raw.feature.properties.name;
                                    const val = item.raw.value;
                                    return val > 0 ? `${name}: ${fmt(val)} min` : `${name}: no data`;
                                }
                            }
                        }
                    },
                    scales: {
                        projection: {
                            axis: 'x',
                            projection: 'equalEarth'
                        },
                        color: {
                            axis: 'x',
                            quantize: 5,
                            interpolate: (v) => {
                                // Gray gradient: lighter-gray (#F5F5F5) → dark-gray (#333333)
                                const c = Math.round(245 + (51 - 245) * v);
                                return `rgb(${c},${c},${c})`;
                            },
                            legend: {
                                position: 'bottom-right',
                                align: 'right'
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const idx = elements[0].index;
                            const feature = chartData[idx].feature;
                            drillIntoCountry(feature.properties.name);
                        }
                    }
                }
            });

            document.getElementById('mapTitle').textContent = 'Minutes Viewed by Location';
            document.getElementById('mapDrillDetail').style.display = 'none';
        }

        async function drillIntoCountry(countryName) {
            currentMapLevel = countryName;
            mapZoomLevel = 1;
            updateMapBreadcrumb();

            if (countryName === 'United States of America') {
                await renderUSStatesMap();
            } else {
                document.getElementById('mapTitle').textContent = `Minutes Viewed — ${countryName}`;
            }

            await renderCountryDrillDetail(countryName);
        }

        async function renderUSStatesMap() {
            const topo = await loadUSTopology();
            const states = ChartGeo.topojson.feature(topo, topo.objects.states).features;

            // Get US total minutes to show uniform coloring across states
            const w = getWhereClause();
            const nameList = getDataCountryNames('United States of America').map(n => `'${n.replace(/'/g, "''")}'`).join(',');
            const usData = await query(`
                SELECT ROUND(SUM(video_seconds_viewed) / 60.0, 0) as total_minutes
                FROM analytics
                WHERE ${w} AND country IN (${nameList}) AND video_seconds_viewed > 0
            `);
            const usTotal = usData[0]?.total_minutes || 0;
            // Distribute evenly so color scale renders visible shading
            const perState = usTotal > 0 ? Math.round(usTotal / states.length) : 0;

            const stateChartData = states.map(f => ({ feature: f, value: perState }));

            if (geoMapChart) { geoMapChart.destroy(); geoMapChart = null; }

            const ctx = document.getElementById('chartGeoMap').getContext('2d');
            geoMapChart = new Chart(ctx, {
                type: 'choropleth',
                data: {
                    labels: states.map(f => f.properties.name),
                    datasets: [{
                        label: 'Minutes Viewed',
                        outline: states,
                        data: stateChartData,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (item) => {
                                    const name = item.raw.feature.properties.name;
                                    return usTotal > 0
                                        ? `${name} (US total: ${fmt(usTotal)} min — state breakdown not yet available)`
                                        : `${name}: no data`;
                                }
                            }
                        }
                    },
                    scales: {
                        projection: { axis: 'x', projection: 'albersUsa' },
                        color: {
                            axis: 'x',
                            quantize: 5,
                            interpolate: (v) => {
                                const r = Math.round(245 + (189 - 245) * v);
                                const g = Math.round(245 + (0 - 245) * v);
                                const b = Math.round(245 + (12 - 245) * v);
                                return `rgb(${r},${g},${b})`;
                            },
                            legend: { display: false }
                        }
                    }
                }
            });

            document.getElementById('mapTitle').innerHTML =
                'Minutes Viewed by State <span style="font-size:0.75rem;color:var(--medium-gray);font-weight:normal;">(state-level breakdown not yet in pipeline)</span>';
        }

        async function renderCountryDrillDetail(countryName) {
            const w = getWhereClause();
            const nameList = getDataCountryNames(countryName).map(n => `'${n.replace(/'/g, "''")}'`).join(',');

            const [summary, topVideos] = await Promise.all([
                query(`
                    SELECT
                        SUM(video_view) as total_views,
                        ROUND(SUM(video_seconds_viewed) / 3600.0, 1) as total_hours,
                        COUNT(DISTINCT video_id) as video_count,
                        ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion_rate
                    FROM analytics
                    WHERE ${w} AND country IN (${nameList})
                `),
                query(`
                    SELECT
                        MAX(name) as name,
                        SUM(video_view) as views,
                        ROUND(SUM(video_seconds_viewed) / 60.0, 0) as minutes_viewed,
                        ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion_pct
                    FROM analytics
                    WHERE ${w} AND country IN (${nameList}) AND video_view > 0
                    GROUP BY video_id
                    ORDER BY minutes_viewed DESC
                    LIMIT 20
                `)
            ]);

            const s = summary[0] || {};
            const detail = document.getElementById('mapDrillDetail');
            detail.style.display = 'block';

            let html = `
                <div class="kpi-grid" style="margin: 1rem 0;">
                    <div class="kpi-card">
                        <div class="kpi-label">Total Views</div>
                        <div class="kpi-value">${fmt(s.total_views)}</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-label">Watch Hours</div>
                        <div class="kpi-value">${fmt(s.total_hours)}</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-label">Videos</div>
                        <div class="kpi-value">${fmt(s.video_count)}</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-label">Completion Rate</div>
                        <div class="kpi-value">${fmtPct(s.completion_rate)}</div>
                    </div>
                </div>
            `;

            if (topVideos.length > 0) {
                html += `<h3 class="section-title">Top Videos — ${countryName}</h3>`;
                html += renderTable(topVideos, [
                    { key: 'name', label: 'Video', fmt: v => truncateStr(v, 60) },
                    { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                    { key: 'minutes_viewed', label: 'Minutes', cls: 'text-right', fmt: fmt },
                    { key: 'completion_pct', label: 'Completion %', cls: 'text-right', fmt: fmtPct }
                ]);
            } else {
                html += `<p style="color:var(--medium-gray);font-size:0.85rem;padding:1rem;">No video data found for ${countryName}.</p>`;
            }

            detail.innerHTML = html;
        }

        function updateMapBreadcrumb() {
            const bc = document.getElementById('mapBreadcrumb');
            if (currentMapLevel === 'world') {
                bc.innerHTML = '<span class="map-crumb active">World</span>';
            } else {
                bc.innerHTML = `
                    <span class="map-crumb" onclick="backToWorldMap()">World</span>
                    <span class="map-separator">›</span>
                    <span class="map-crumb active">${currentMapLevel}</span>
                `;
            }
        }

        async function backToWorldMap() {
            currentMapLevel = 'world';
            mapZoomLevel = 1;
            updateMapBreadcrumb();
            document.getElementById('mapDrillDetail').style.display = 'none';
            await renderWorldMap();
        }

        // ====================================================================
        // REGIONAL: COUNTRY VIEWS
        // ====================================================================
        async function renderCountryViews() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    SUM(video_view) as views
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY 1
                ORDER BY views DESC
                LIMIT 15
            `);

            destroyChart('chartCountryViews');
            const ctx = document.getElementById('chartCountryViews').getContext('2d');
            charts['chartCountryViews'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.country),
                    datasets: [{
                        data: data.map(r => r.views),
                        backgroundColor: data.map((_, i) => COLORS.palette[i % COLORS.palette.length] + '99'),
                        borderColor: data.map((_, i) => COLORS.palette[i % COLORS.palette.length]),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { beginAtZero: true, ticks: { callback: v => fmt(v) } }
                    }
                }
            });
        }

        // ====================================================================
        // REGIONAL: COUNTRY BUBBLE CHART
        // ====================================================================
        async function renderCountryBubble() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    SUM(video_view) as views,
                    ROUND(SUM(video_seconds_viewed) * 1.0 / NULLIF(SUM(video_view), 0), 1) as avg_seconds_per_view,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 1) as watch_hours
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY 1
                HAVING SUM(video_view) >= 50
                ORDER BY views DESC
                LIMIT 30
            `);

            const maxHours = Math.max(...data.map(r => r.watch_hours), 1);

            destroyChart('chartCountryBubble');
            const ctx = document.getElementById('chartCountryBubble').getContext('2d');
            charts['chartCountryBubble'] = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: data.map((r, i) => ({
                        label: r.country,
                        data: [{
                            x: r.views,
                            y: r.avg_seconds_per_view,
                            r: Math.max(4, Math.sqrt(r.watch_hours / maxHours) * 40)
                        }],
                        backgroundColor: COLORS.palette[i % COLORS.palette.length] + '88',
                        borderColor: COLORS.palette[i % COLORS.palette.length],
                        borderWidth: 1
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: ctx => {
                                    const d = data[ctx.datasetIndex];
                                    return [
                                        d.country,
                                        `Views: ${fmt(d.views)}`,
                                        `Avg: ${d.avg_seconds_per_view}s per view`,
                                        `Watch hours: ${d.watch_hours}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Total Views' },
                            ticks: { callback: v => fmt(v) }
                        },
                        y: {
                            title: { display: true, text: 'Avg Seconds per View' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // ====================================================================
        // REGIONAL: COUNTRY ENGAGEMENT
        // ====================================================================
        async function renderCountryEngagement() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY 1
                HAVING SUM(video_view) >= 100
                ORDER BY completion DESC
                LIMIT 15
            `);

            destroyChart('chartCountryEngagement');
            const ctx = document.getElementById('chartCountryEngagement').getContext('2d');
            charts['chartCountryEngagement'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(r => r.country),
                    datasets: [{
                        data: data.map(r => r.completion),
                        backgroundColor: data.map(r => r.completion > 50 ? COLORS.success + '99' : r.completion > 30 ? COLORS.warning + '99' : COLORS.danger + '99'),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: ctx => fmtPct(ctx.raw),
                                afterLabel: (ctx) => `${fmt(data[ctx.dataIndex].views)} views`
                            }
                        }
                    },
                    scales: {
                        x: { beginAtZero: true, max: 100, ticks: { callback: v => v + '%' } }
                    }
                }
            });
        }

        // ====================================================================
        // REGIONAL: COUNTRY TABLE
        // ====================================================================
        async function renderCountryTable() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    COUNT(DISTINCT video_id) as num_videos,
                    SUM(video_view) as views,
                    ROUND(SUM(video_view) * 1.0 / NULLIF(COUNT(DISTINCT video_id), 0), 0) as views_per_video,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion,
                    ROUND(SUM(views_mobile) * 100.0 / NULLIF(SUM(video_view), 0), 1) as mobile_pct
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY 1
                ORDER BY views DESC
            `);

            document.getElementById('countryTable').innerHTML = renderTable(data, [
                { key: 'country', label: 'Country' },
                { key: 'num_videos', label: 'Videos', cls: 'text-right', fmt: fmt },
                { key: 'views', label: 'Total Views', cls: 'text-right', fmt: fmt },
                { key: 'views_per_video', label: 'Views/Video', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct },
                { key: 'mobile_pct', label: 'Mobile %', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // REGIONAL: TOP VIDEOS BY COUNTRY
        // ====================================================================
        async function renderCountryTopVideos() {
            const w = getWhereClause();
            const data = await query(`
                SELECT
                    COALESCE(NULLIF(country, ''), 'Unknown') as country,
                    channel,
                    video_id,
                    MAX(name) as name,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY 1, 2, 3
                ORDER BY views DESC
                LIMIT 30
            `);

            document.getElementById('countryTopVideos').innerHTML = renderTable(data, [
                { key: 'country', label: 'Country' },
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 60) },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // STALE CONTENT
        // ====================================================================
        async function renderStaleContent() {
            const channelWhere = channelFilterValue.length > 0 ? `AND d.channel IN (${channelFilterValue.map(c => `'${c.replace(/'/g, "''")}'`).join(',')})` : '';
            const videoWhere = videoSearchValue.length >= 2 ? `AND d.name ILIKE '%${videoSearchValue.replace(/'/g, "''")}%'` : '';
            const data = await query(`
                SELECT
                    d.channel,
                    d.video_id,
                    d.name,
                    d.video_duration_seconds,
                    d.created_at
                FROM dims d
                WHERE d.video_id IN (
                    SELECT video_id
                    FROM facts
                    WHERE dt_last_viewed IS NOT NULL
                    GROUP BY video_id
                    HAVING CAST(MAX(dt_last_viewed) AS DATE) < CURRENT_DATE - INTERVAL '180 days'
                )
                ${channelWhere}
                ${videoWhere}
                ORDER BY d.name
                LIMIT 50
            `);

            if (data.length === 0) {
                document.getElementById('staleContent').innerHTML = '<p style="color:var(--medium-gray);font-size:0.85rem;">No stale content found -- all videos viewed within 180 days.</p>';
                return;
            }

            document.getElementById('staleContent').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'video_duration_seconds', label: 'Duration', cls: 'text-right', fmt: fmtDuration },
                { key: 'created_at', label: 'Created', fmt: v => v ? String(v).substring(0, 10) : '-' }
            ]);
        }

        // ====================================================================
        // RECENT PERFORMERS
        // ====================================================================
        async function renderRecentPerformers() {
            const channelWhere = channelFilterValue.length > 0 ? `AND channel IN (${channelFilterValue.map(c => `'${c.replace(/'/g, "''")}'`).join(',')})` : '';
            const videoWhere = videoSearchValue.length >= 2 ? `AND name ILIKE '%${videoSearchValue.replace(/'/g, "''")}%'` : '';
            const data = await query(`
                SELECT
                    channel,
                    video_id,
                    MAX(name) as name,
                    SUM(video_view) as views,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as completion
                FROM analytics
                WHERE date >= CURRENT_DATE - INTERVAL '30 days'
                  AND video_view > 0
                  ${channelWhere}
                  ${videoWhere}
                GROUP BY channel, video_id
                ORDER BY views DESC
                LIMIT 20
            `);

            document.getElementById('recentPerformers').innerHTML = renderTable(data, [
                { key: 'channel', label: 'Channel' },
                { key: 'name', label: 'Video Name', fmt: v => truncateStr(v, 70) },
                { key: 'views', label: 'Views (30d)', cls: 'text-right', fmt: fmt },
                { key: 'completion', label: 'Completion', cls: 'text-right', fmt: fmtPct }
            ]);
        }

        // ====================================================================
        // EXPLORE TAB
        // ====================================================================
        async function populateChannelFilter() {
            const data = await query(`SELECT DISTINCT channel FROM dims WHERE channel IS NOT NULL ORDER BY channel`);
            allChannels = data.map(r => r.channel);
            renderChannelOptions();
        }

        function renderChannelOptions(filter) {
            const container = document.getElementById('channelOptions');
            const allChecked = channelFilterValue.length === 0;
            const term = (filter || '').toLowerCase();
            const filtered = term ? allChannels.filter(ch => ch.toLowerCase().includes(term)) : allChannels;

            let html = `<label class="multi-select-option" style="border-bottom:1px solid var(--light-gray);font-weight:600;"${term ? ' style="display:none"' : ''}>` +
                `<input type="checkbox" id="channelSelectAll"${allChecked ? ' checked' : ''} onchange="onChannelSelectAll()">All Channels</label>`;
            if (term) html = '';
            html += filtered.map(ch => {
                const checked = allChecked || channelFilterValue.includes(ch) ? ' checked' : '';
                return `<label class="multi-select-option"><input type="checkbox" value="${ch}"${checked} onchange="onChannelCheckboxChange()">${ch}</label>`;
            }).join('');
            if (filtered.length === 0) html = '<div style="padding:0.5rem 0.6rem;font-size:0.8rem;color:var(--medium-gray);">No matches</div>';
            container.innerHTML = html;
        }

        function filterChannelOptions() {
            const term = document.getElementById('channelSearchInput').value.trim();
            renderChannelOptions(term);
        }


        // ====================================================================
        // VIDEO TABLE (full ranked table matching Brightcove export style)
        // ====================================================================
        let videoTableData = [];
        let videoTableSort = { key: 'views', dir: 'desc' };
        let videoTablePage = 0;
        const VIDEO_TABLE_PAGE_SIZE = 50;

        async function renderVideoTable() {
            const w = getWhereClause();
            videoTableData = await query(`
                SELECT
                    video_id,
                    MAX(name) as name,
                    MAX(channel) as channel,
                    SUM(video_view) as views,
                    SUM(video_impression) as impressions,
                    ROUND(SUM(video_view) * 100.0 / NULLIF(SUM(video_impression), 0), 1) as play_rate,
                    ROUND(SUM(video_engagement_1) * 100.0 / NULLIF(SUM(video_view), 0), 1) as pct_1,
                    ROUND(SUM(video_engagement_25) * 100.0 / NULLIF(SUM(video_view), 0), 1) as pct_25,
                    ROUND(SUM(video_engagement_50) * 100.0 / NULLIF(SUM(video_view), 0), 1) as pct_50,
                    ROUND(SUM(video_engagement_75) * 100.0 / NULLIF(SUM(video_view), 0), 1) as pct_75,
                    ROUND(SUM(video_engagement_100) * 100.0 / NULLIF(SUM(video_view), 0), 1) as pct_100,
                    SUM(views_desktop) as desktop,
                    SUM(views_mobile) as mobile,
                    SUM(views_tablet) as tablet,
                    ROUND(MAX(video_duration_seconds), 0) as duration_sec,
                    ROUND(SUM(video_seconds_viewed) / 3600.0, 2) as watch_hours,
                    ROUND(SUM(video_seconds_viewed) * 100.0 / NULLIF(SUM(video_view) * MAX(video_duration_seconds), 0), 1) as engagement_score
                FROM analytics
                WHERE ${w} AND video_view > 0
                GROUP BY video_id
                ORDER BY views DESC
            `);
            videoTablePage = 0;
            renderVideoTablePage();
        }

        function renderVideoTablePage() {
            const cols = [
                { key: '_rank', label: 'Rank', cls: 'text-right' },
                { key: 'video_id', label: 'Video ID' },
                { key: 'name', label: 'Video Name' },
                { key: 'channel', label: 'Channel' },
                { key: 'views', label: 'Views', cls: 'text-right', fmt: fmt },
                { key: 'impressions', label: 'Impressions', cls: 'text-right', fmt: fmt },
                { key: 'play_rate', label: 'Play Rate %', cls: 'text-right', fmt: fmtPct },
                { key: 'pct_1', label: 'Views at 1%', cls: 'text-right', fmt: fmtPct },
                { key: 'pct_25', label: 'Views at 25%', cls: 'text-right', fmt: fmtPct },
                { key: 'pct_50', label: 'Views at 50%', cls: 'text-right', fmt: fmtPct },
                { key: 'pct_75', label: 'Views at 75%', cls: 'text-right', fmt: fmtPct },
                { key: 'pct_100', label: 'Views at 100%', cls: 'text-right', fmt: fmtPct },
                { key: 'desktop', label: 'Desktop', cls: 'text-right', fmt: fmt },
                { key: 'mobile', label: 'Mobile', cls: 'text-right', fmt: fmt },
                { key: 'tablet', label: 'Tablet', cls: 'text-right', fmt: fmt },
                { key: 'duration_sec', label: 'Duration', cls: 'text-right', fmt: fmtDuration },
                { key: 'watch_hours', label: 'Watch Hours', cls: 'text-right', fmt: v => v != null ? Number(v).toFixed(2) : '-' },
                { key: 'engagement_score', label: 'Engagement %', cls: 'text-right', fmt: fmtPct }
            ];

            // Sort
            const sorted = [...videoTableData];
            const sk = videoTableSort.key;
            if (sk && sk !== '_rank') {
                sorted.sort((a, b) => {
                    const va = a[sk] ?? -Infinity;
                    const vb = b[sk] ?? -Infinity;
                    if (typeof va === 'string') return videoTableSort.dir === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
                    return videoTableSort.dir === 'asc' ? va - vb : vb - va;
                });
            }

            const total = sorted.length;
            const totalPages = Math.ceil(total / VIDEO_TABLE_PAGE_SIZE);
            const start = videoTablePage * VIDEO_TABLE_PAGE_SIZE;
            const page = sorted.slice(start, start + VIDEO_TABLE_PAGE_SIZE);

            document.getElementById('videoTableCount').textContent = `${total} videos`;

            // Build header with sort indicators
            const arrow = (key) => {
                if (videoTableSort.key !== key) return '';
                return videoTableSort.dir === 'asc' ? ' \u25B2' : ' \u25BC';
            };
            const header = cols.map(col => {
                const sortable = col.key !== '_rank';
                return `<th class="${col.cls || ''}" ${sortable ? `onclick="sortVideoTable('${col.key}')" style="cursor:pointer;user-select:none;"` : ''}>${col.label}${arrow(col.key)}</th>`;
            }).join('');

            const rows = page.map((row, i) => {
                const rank = start + i + 1;
                return '<tr>' + cols.map(col => {
                    let val;
                    if (col.key === '_rank') val = rank;
                    else val = row[col.key];
                    const display = col.fmt ? col.fmt(val) : (val != null ? val : '-');
                    const tdStyle = col.key === 'name' ? ' style="max-width:300px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"' : '';
                    return `<td class="${col.cls || ''}"${tdStyle}>${display}</td>`;
                }).join('') + '</tr>';
            }).join('');

            document.getElementById('videoTableContainer').innerHTML = `
                <div class="table-container" style="max-height:600px;">
                    <table>
                        <thead><tr>${header}</tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
            `;

            // Pagination
            if (totalPages > 1) {
                let pag = '';
                pag += `<button class="btn btn-secondary" onclick="videoTableGoPage(0)" ${videoTablePage === 0 ? 'disabled' : ''}>&laquo;</button>`;
                pag += `<button class="btn btn-secondary" onclick="videoTableGoPage(${videoTablePage - 1})" ${videoTablePage === 0 ? 'disabled' : ''}>&lsaquo;</button>`;
                pag += `<span style="font-size:0.8rem;">Page ${videoTablePage + 1} of ${totalPages}</span>`;
                pag += `<button class="btn btn-secondary" onclick="videoTableGoPage(${videoTablePage + 1})" ${videoTablePage >= totalPages - 1 ? 'disabled' : ''}>&rsaquo;</button>`;
                pag += `<button class="btn btn-secondary" onclick="videoTableGoPage(${totalPages - 1})" ${videoTablePage >= totalPages - 1 ? 'disabled' : ''}>&raquo;</button>`;
                document.getElementById('videoTablePagination').innerHTML = pag;
            } else {
                document.getElementById('videoTablePagination').innerHTML = '';
            }
        }

        function sortVideoTable(key) {
            if (videoTableSort.key === key) {
                videoTableSort.dir = videoTableSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                videoTableSort.key = key;
                videoTableSort.dir = key === 'name' || key === 'channel' || key === 'video_id' ? 'asc' : 'desc';
            }
            videoTablePage = 0;
            renderVideoTablePage();
        }

        function videoTableGoPage(p) {
            const totalPages = Math.ceil(videoTableData.length / VIDEO_TABLE_PAGE_SIZE);
            videoTablePage = Math.max(0, Math.min(p, totalPages - 1));
            renderVideoTablePage();
        }

        // ====================================================================
        // VIDEO TABLE EXPORT (CSV / Excel)
        // ====================================================================
        function exportVideoTable(format) {
            if (!videoTableData || videoTableData.length === 0) return;

            const headers = [
                'Rank', 'Video ID', 'Video Name', 'Channel', 'Views', 'Impressions',
                'Play Rate %', 'Views at 1%', 'Views at 25%', 'Views at 50%',
                'Views at 75%', 'Views at 100%', 'Desktop', 'Mobile', 'Tablet',
                'Duration (s)', 'Watch Hours', 'Engagement %'
            ];
            const keys = [
                '_rank', 'video_id', 'name', 'channel', 'views', 'impressions',
                'play_rate', 'pct_1', 'pct_25', 'pct_50', 'pct_75', 'pct_100',
                'desktop', 'mobile', 'tablet', 'duration_sec', 'watch_hours', 'engagement_score'
            ];

            // Sort data like current view
            const sorted = [...videoTableData];
            const sk = videoTableSort.key;
            if (sk && sk !== '_rank') {
                sorted.sort((a, b) => {
                    const va = a[sk] ?? -Infinity;
                    const vb = b[sk] ?? -Infinity;
                    if (typeof va === 'string') return videoTableSort.dir === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
                    return videoTableSort.dir === 'asc' ? va - vb : vb - va;
                });
            }

            const rows = sorted.map((row, i) =>
                keys.map(k => {
                    if (k === '_rank') return i + 1;
                    const v = row[k];
                    return v != null ? v : '';
                })
            );

            if (format === 'csv') {
                const escape = v => {
                    const s = String(v);
                    return s.includes(',') || s.includes('"') || s.includes('\n') ? '"' + s.replace(/"/g, '""') + '"' : s;
                };
                const csv = [headers.map(escape).join(','), ...rows.map(r => r.map(escape).join(','))].join('\n');
                downloadFile(csv, 'video-analytics.csv', 'text/csv;charset=utf-8;');
            } else {
                // Build proper .xlsx using SheetJS
                const ws = XLSX.utils.aoa_to_sheet([headers, ...rows]);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Video Analytics');
                XLSX.writeFile(wb, 'video-analytics.xlsx');
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ====================================================================
        // TABLE RENDERER
        // ====================================================================
        function renderTable(data, columns) {
            if (!data || data.length === 0) {
                return '<p style="color:var(--medium-gray);font-size:0.85rem;">No data available.</p>';
            }

            const header = columns.map(col =>
                `<th class="${col.cls || ''}">${col.label}</th>`
            ).join('');

            const rows = data.map(row =>
                '<tr>' + columns.map(col => {
                    const val = row[col.key];
                    const display = col.fmt ? col.fmt(val) : (val != null ? val : '-');
                    return `<td class="${col.cls || ''}">${display}</td>`;
                }).join('') + '</tr>'
            ).join('');

            return `
                <div class="table-container">
                    <table>
                        <thead><tr>${header}</tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
            `;
        }

        // ====================================================================
        // START
        // ====================================================================
        init();
    </script>
</body>
</html>
